视频学习网站：[https://www.imooc.com/learn/1086](https://www.imooc.com/learn/1086)

# synchronized作用

能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。

# synchronized的两个用法

对象锁：

- 方法锁（锁的是this）
- 同步代码块

类锁：

- 修饰静态方法（锁的是class对象）
- 指定锁为Class对象

如果不是static，则被synchronized修饰的方法，两个实例调用不是一把锁

# 多线程访问同步方法的7种情况

两个线程同时访问一个对象（即runnable接口是一个实例）的同步方法（起作用）

两个线程访问的是两个对象（即runnable接口不是一个实例）的同步方法（不起作用）

两个线程访问的是一个对象/两个对象synchronized的静态方法（起作用）

两个线程同时访问同步方法与非同步方法（非同步方法的访问不被影响）

两个线程同时访问同一个对象的不同的普通同步方法（两个方法的访问无法同时进行，因为是一把锁）

同时访问静态synchronized和非静态 synchronized方法（两个方法的访问可以同时进行，非静态锁的是this，静态锁的是class对象）

方法拋异常后，JVM会帮我们释放锁，Lock抛出异常后不会释放锁，需要显式释放

# 3个核心思想

- 把锁只能同时被一个线程获取,没有拿到锁的线程必须等待(对应第1、5种情况)
- 每个实例都对应有自己的一把锁,不同实例之间互不影响;例外锁对象是* class以及 synchronized 修饰的是 static方法的时候,所有对象共用同一把类锁(对应第2、3、4、6种情况)
- 无论是方法正常执行完毕或者方法抛岀异常,都会释放锁(对应第7种情况)

# synchronized的性质

## 可重入性质

什么是可重入（递归锁）：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。类似牌照摇号，可重入就是拿到之后就可以再次用起来，可以一直摇号，如果还需要重新竞争的话就叫不可重入锁

有什么好处：避免死锁、提升封装性

## synchronized控制粒度

粒度∶线程而非调用（用3种情况来说明和 pthread（调用）的区别），只要线程拿到了锁，访问其他的方法需要的是这同一把锁，就不需要再去获取这把锁

- 情况1：证明同一个方法是可重入的（synchronized方法调用本身）
- 情况2：证明可重入不要求是同一个方法（synchronized方法调用另一个synchronized方法）
- 情况3：证明可重入不要求是同一个类中的（synchronized方法调用其他类的synchronized方法）

## 不可中断性质

一旦这个锁已经被别人获得了，如果我还想获得,我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁那么我只能永远地等下去。

相比之下，未来会介绍的Lock类，可以拥有中断的能力。第一点，如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行。第二点，如果我觉得我等待的时间太长了不想再等了，也可以退出。

# synchronized原理

## 加锁和释放锁

获取和释放锁的时机是通过内置锁（监视器锁），线程在进入同步代码块之前会自动获取这个锁，退出会自动释放这个锁。

Monditorenter和 Monditorexit指令，每个对象都与一个Monditor相关联，而Monditor的Lock锁同一时间只能被同一线程获得，Monditorenter开始是0，如果线程访问这个对象，发现是0就会立刻获取，同时给Monditorenter加一，其他线程无法获取，再次重入也会加一，Monditorexit之后Monditorenter减一

## 可重入原理

可重入原理：加锁次数计数器

JVM负责跟踪对象被加锁的次数，线程第一次给对象加锁的时候,计数变为1。每当这个相同的线程在此对象上再次获得锁时，计数会递增。每当任务离开时,计数递减，当计数为0的时候，锁被完全释放

## 可见性原理

通过JMM（Java内存模型）进行控制

# synchronized缺陷

- 效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程
- 不够灵活(读写锁更灵活)：加锁和释放的时机单一，每个锁仅有单一的条件(某个对象)，可能是不够的
- 无法知道是否成功获取到锁，Lock可以指定成功了怎么办，失败了怎么办

> Lock可以克服这三个缺点

# 常见面试题

```markdown
synchronized关键字使用有什么注意点？
	锁对象不能为空、作用域不宜过大、避免死锁

如何选择Lock和 synchronized关键字？
	如果可以的话都不使用，使用utils.cur等类
	优先使用synchronized，可以减少代码和出错
	如果真的必须要用Lock和Condition的特性再去使用

多线程访问同步方法的各种具体情况
	就是多线程访问同步方法的7种情况
```

# 一些思考题

```markdown
多个线程等待同一个synchronized锁的时候,JVM如何选择下个获取锁的是哪个线程?
	目前是不公平的状态，和JVM有关
Synchronized使得同时只有一个线程可以执行,性能较差,有什么办法可以提升性能?
	优化使用范围
	使用其他类型Lock
我想更灵活地控制锁的获取和释放(现在释放锁的时机都被规定死了),怎么办?
	可以自己实现一个锁
什么是锁的升级、降级?什么是JVM里的偏向锁、轻量级锁、重量级锁?
	以前的synchronized锁性能不高，后来出了偏向锁、轻量级锁、重量级锁等东西提高了它的性能，JVM会根据使用的种种指标来对锁进行优化，还涉及对象头的一些字段
```





